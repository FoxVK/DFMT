\section{Knihovna a demonstrační aplikace}
\label{sec:knihovna}

Knihovnu pro ovládání tuneru jsem nazval libdfmt. Je napsána v jazyce C. Pro přístup k USB rozhraní jsem využil knihovnu libusb~1.0, jejíž použití je výhodné protože je multiplatformní, je široce využívaná jak pod OS Windows tak pod OS Linux a je velmi dobře zdokumentovaná.

Knihovna je rozdělena do čtyř částí. První částí je rozhraní umožňující vyhledání a připojení k modulu. další tři části tvoří  tři úrovně přístupu k samotným tunerům na modulu. Funkce v nejnižší úrovni zprostředkovávají přístup přímo k USB - \iic tunelu (popsán v kapitole \ref{subsec:tunel}). Sada funkcí střední úrovně umožňuje odesílání příkazů, příjem odpovědí a čtení a zápis proměnných v jednotlivých tunerech. Vysokoúrovňové funkce umožňují ladění a zjišťování informací o naladěných frekvencích a příjem RDS.

Definice všech funkcí a datových struktur je v jediném hlavičkovém souboru libdfmt.h. ROzhraní všech funkcí je okomentováno komentáři kompatibilními se formátem javadoc. Na přiloženém CD je ke knihovně vygenerovaná dokumentace v HTML formátu.

%TODO HTML do zkratek

\begin{itemize}
\item udev rules a windows driver
\end{itemize}

\subsection{Vyhledávání a správa zařízení}

Správa zařízení byla psána s ohledem na možnost současného ovládání více připojených zařízení a také na možnost jednoduchého začlenění do případného událostního systému.

Knihovnu je potřeba nejprve inicializovat funkcí \verb|libdfmt_init()|. Vyhledávání zařízení se provede funkcí \verb|libdfmt_scan_devs()|. Seznam ukazatelů na struktury reprezentující všechna připojená zařízení se získá zavoláním funkce \verb|libdfmt_scan_devs()|. V případě, že nebyl nalezen žádný tuner funkce vrací NULL. Seznam lze procházet pomocí funkce \verb|libdfmt_next()|. 

Pro ovládání jednotlivých tunerů je potřeba nejprve zařízení otevřít funkcí \verb|libdfmt_dev_open()|. Dále je třeba získat ukazatele reprezentující jednotlivé tunery na zařízení. To se provede pomocí funkce \verb|libdfmt_get_tuners()|.

Pro napojení do událostního systému je možné zaregistrovat pomocí funkcí \verb|libdfmt_new_dev_cb()| a \verb|libdfmt_removed_dev_cb()| vlastní funkce, které budou zavolány při detekci připojení nebo odpojení zařízení. V parametru jsou do těchto funkcí vždy předány ukazatele na zařízení, na kterém tato událost nastala.

Po ukončení práce se zařízením je vhodné jej uzavřít zavoláním funkce \verb|libdfmt_dev_close()|. Při ukončení aplikace nebo ukončení práce se všemi tunery je vhodné knihovnu uzavřít a uvolnit jí alokované prostředky voláním \verb|libdfmt_exit()|.

\begin{lstlisting}[label=src:lib-mgm, caption=Ukázka práce s knihovnou.]
libdfmt_init(0);

libdfmt_scan_devs();
Libdfmt_device *devs = libdfmt_get_all_devs();

while(devs){
	Libdfmt_tuner *t_a, *t_b;
	libdfmt_get_tuners(devs, &t_a, &t_b);

	libdfmt_dev_open(devs);
	libdfmt_tune(t_a, 97.3);
	libdfmt_dev_close(devs);

	devs = libdfmt_next(devs);
}

libdfmt_exit();
\end{lstlisting}

Příklad práce s knihovnou je ve výpisu \ref{src:lib-mgm}. Provede se zde inicializace knihovny a vyhledání všech připojených zařízení. Poté se nalezená zařízení postupně v cyklu otevřou, na tuneru A se naladí frekvence 93,7 MHz a uzavřou.

\subsection{Nízkoúrovňové funkce}
Nízko do nízko úrovňových funkcí spadají pouze tři funkce funkce. \verb|libdfmt_i2c_com()| umožňuje zápis pole dat přes \iic sběrnici do zvoleného tuneru a nebo čtení zadaného množství dat z tuneru. Je to základní funkce zapouzdřující rozhraní USB - \iic tunelu.

Zbylá dvojice funkcí \verb|libdfmt_i2c_send()| a \verb|libdfmt_i2c_recv()|  tvoří jakési přetížení předchozí funkce pro zápis a čtení.

\subsection{Středoúrovňové funkce}

Tyto funkce tvoří rozhraní pro odesílání příkazů, čtení odpovědí a poskytují rozhraní pro práci s proměnnými v tunerech. Dale jdou zde funkce k zjišťování stavu tunerů. Hlavním účelem těchto funkcí je umožnit jednoduché rozšiřování funkcionality knihovny.

Pro práci s příkazy slouží funkce \verb|libdfmt_cmd_send()| a \verb|libdfmt_cmd_recv_reply()|. První uvedená provede před odesláním kontrolu jestli tuner není zaneprázdněn. Pokud toto chování není žádoucí je možné použit funkci \verb|libdfmt_cmd_send_nocheck()|, která kontrolu neprovádí.

Čtení a zápis hodnot do proměnných tuneru se provádí funkcemi \verb|libdfmt_prop_get()| a \verb|libdfmt_prop_set()|.

Dále se zde nachází funkce \verb|libdfmt_cmd_status()|, která získá status daného tuneru. Funkce \verb|libdfmt_check_bussy()| je vlastně variantou předchozí funkce, která pouze ověřuje jestli je možné odeslat další příkaz. Poslední funkcí je \verb|libdfmt_check_int()|. Tato funkce provede aktualizaci příznaků přerušení v tuneru a přečte jejich hodnoty.

\subsection{Vysokoúrovňové funkce}
Tato sada funkcí umožňuje ladění a vyhledávání stanic, získání parametrů signálu naladěné stanice a čtení RDS.

\begin{itemize}
\item \verb|libdfmt_seek()| - Vyhledání stanice.
\item \verb|libdfmt_tune()| - Přeladění na danou frekvenci. 
\item \verb|libdfmt_tunning_done()| - Získá jestli bylo ladění nebo vyhledávání stanice dokončeno.
\item \verb|libdfmt_get_freq()| - Přečtení aktuální naladěnou frekvenci.
\item \verb|libdfmt_get_metrics()| - Získá parametry signálu naladěné frekvence.
\item \verb|libdfmt_rds_receiving()| - Povolí nebo zakáže příjem RDS.
\item \verb|libdfmt_rds_read()| - Přečte jednu RDS skupinu.
\end{itemize}

\subsection{Ovladače pro knihovnu}
Pro přenos zvuku byla využita standardní třída USB funkcí. Na základě této informace si operační systémy vyhledají příslušný ovladač této třídy a ten použijí. Rozhraní pro ovládání modulu (USB - \iic tunel) žádnou standardní třídu nemá. Je tedy potřeba operačnímu systému sdělit jaký ovladač má použít.

Konkrétně tím, že knihovna k USB přistupuje pomocí knihovny libusb 1.0, je potřeba použít ovladač, který libusb umí používat.

\subsubsection{Pro OS Linux}
Pod OS Linux je potřeba pouze přidat pravidlo pro udev, které při každém připojení modulu, nastaví práva pro čtení a zápis na soubory reprezentující v systému koncové body USB - \iic tunelu. Ve výchozím nastavení mají tyto soubory nastavena pouze práva pro čtení, takže k nim nelze přestupovat.

\begin{lstlisting}[language=bash, label=src:lib-linux-drv, caption=Přídání udev pravidla.]
cp 98-dfmt.rules /etc/udev/rules.d/
udevadm control --reload-rules
\end{lstlisting}

Pravidlo je předpřipraveno v souboru 98-dfmt.rules ve složce driver/linux/ na přiloženém CD. Nakopírování pravidla a příkaz znovu-načtení pravidel subsystémem udev ukazuje výpis \ref{src:lib-linux-drv}. Oba příkazy je nutné spouštět s právy superuživatele.

\subsubsection{Pro OS Windows}
Pod OS Windows je situace trochu komplikovanější. K libusb je doporučován ovladač WinUSB. Při použití tohoto ovladače docházelo při pokusu o otevření zařízení funkcí \verb|libusb_open()| k chybě LIBUSB\_ERROR\_NOT\_FOUND. Vyzkoušel jsem tedy ovladač libusbK, který je doporučován pro libusb pro jazyk .NET. S tímto ovladačem pracuje knihovna překvapivě správně.

Uživatelsky nejméně přívětivý způsob instalace je vyhledání nerozpoznaného zařízení ve správci zařízení a výběr ovladače v menu u tohoto zařízení. Naopak uživatelsky nejpřívětivější by bylo využití projektu libwdi \cite{libwdi}, který umožňuje instalaci ovladačů integrovat přímo do aplikace.

\InsertFigure{figures/dfmt-win-drv-install.png}{120mm}{Instalace ovladače pro Windows}{fig:zadig}

Pro instalaci ovladačů jsem se rozhodl využít aplikaci Zadig \cite{zadig}, která vznikla v rámci projektu libwdi. Aplikace obecně umožňuje instalaci některého z ovladačů pro použití libusb včetně vyhledání a zobrazení seznamu zařízení, která by tento ovladač mohla potřebovat. Chování aplikace je možné přizpůsobit přiložením konfiguračního souboru zadig.ini. Tento jsem upravil tak, že aplikace vyhledává přímo modul tuneru, a instaluje pro něj ovladač libusbK. Pro instalaci ovladače tedy stačí připojit modul k počítači, spustit aplikaci drv\_install.exe ve složce driver/win/ na přiloženém CD. Po zobrazení názvu modulu v rozbalovacím seznamu v horní části aplikace, kliknout na tlačítko "Install WCID driver" viz. obrázek \ref{fig:zadig}.

Další možnost instalace je použití Windows compatible device ID. Doplněním modulu o jeden řetězcový deskriptor a odpověď na jeden požadavek bude mít windows možnost zjistit "compatible ID" (ID kompatibility). Na základě této informace vyhledá olvadač v systému a nebo na windows update a nainstaluje jej. V \cite{wcid} je   podrobný popis tohoto deskriptoru a požadavku tak, aby byl kompatibilní s instalovanými ovladači aplikací Zadig. Údajně by Windows Vista a novější měly ovladač instalovat zcela automaticky. 

Doplnil jsem podporu pro Windows compatible device ID. Analyzátorem jsem ověřil, že OS tyto informace opravdu čte, ale zatím nikdy na základě těchto informací nedošlo k instalaci ovladače.

\subsection{Demonstrační aplikace}
Demonstrační aplikace je napsána v jazyce C++ s využitím grafického frameworku Qt5.

TODO: Problém přiřazení zvukové karty konkrétnímu zařízení

\subsection{Překlad}
TODO